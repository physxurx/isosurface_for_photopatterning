#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Nov  7 16:14:17 2025

@Purpose:
    This program generates a 2D array of alternating ±1/2 vortices (defects),
    computes their orientation (director) field, and visualizes both the grid
    structure and isosurfaces of the azimuthal angle.

    It can be interpreted as a visualization of nematic liquid crystal defects
    arranged in a periodic lattice.

@author: Rongxing Xu

@email: xurongxing123@gmail.com

"""
import os
import numpy as np
import matplotlib.pyplot as plt

# ==== Generate internal grid points ====

def generate_internal_grid_points(n, Lx, Ly):
    """
    Generate internal grid points (excluding boundaries),
    producing (n+1)^2 coordinates uniformly distributed
    within (0, Lx) x (0, Ly).
    """
    xs = np.linspace(0, Lx, n+1)  # Exclude boundary edges
    ys = np.linspace(0, Ly, n+1)
    return np.array([(x, y) for x in xs for y in ys])


def generate_winding_numbers(n, q0):
    """
    Generate alternating winding numbers q = ±q0
    on a (n+1) x (n+1) grid, using (-1)^(i+j) pattern.
    """
    return np.array([
        q0 * (-1) ** (i + j)
        for i in range(n+1)
        for j in range(n+1)
    ])


def generate_polygon_vertices(center, sides, radius, 
                              rotation_deg=0):
    """
    Generate vertices of a regular polygon.

    Parameters:
    - center: (x, y) center of the polygon
    - sides: number of edges
    - radius: distance from center to vertex
    - rotation_deg: optional rotation in degrees
    """
    angles = np.linspace(0, 2 * np.pi, sides, endpoint=False)
    angles += np.deg2rad(rotation_deg)
    x = center[0] + radius * np.cos(angles)
    y = center[1] + radius * np.sin(angles)
    return np.stack([x, y], axis=-1)


def vortex_field(x, y, red_positions, red_charges):
    """
    Compute the director field (vx, vy) at point (x, y)
    generated by multiple vortices.

    Each vortex contributes an azimuthal rotation:
        θ += q * arctan2(dy, dx)
    where q is the winding number (±1/2).

    The resulting orientation is normalized as (cosθ, sinθ).
    """
    theta = 0
    for r0, q in zip(red_positions, red_charges):
        dx = x - r0[0]
        dy = y - r0[1]
        # theta += q * (np.arctan2(dy, dx)) + np.pi / 2
        theta += q * (np.arctan2(dy, dx))
    vx = np.cos(theta + apert)
    vy = np.sin(theta + apert)
    return vx, vy


def plot_grid_and_vertices(grid_points, all_vertices, red_charges, Lx, Ly, fname):
    """
    Plot all grid points and their surrounding polygon vertices.
    Blue markers represent +1/2 defects,
    Red markers represent -1/2 defects.
    """
    fig, ax = plt.subplots(figsize=(6, 6))
    ax.set_aspect('equal')
    ax.plot(grid_points[:, 0], grid_points[:, 1], 'ko', markersize=5)  # Grid centers

    # Loop over polygons
    for verts, q in zip(all_vertices, red_charges[::sides]):
        if q < 0:
            color = 'red'   # -1/2 defects
        elif q > 0:
            color = 'blue'  # +1/2 defects
        ax.plot(verts[:, 0], verts[:, 1], 'o', c=color, markersize=5)

    ax.set_xlim(0, Lx)
    ax.set_ylim(0, Ly)
    ax.axis('off')
    plt.tight_layout()
    plt.savefig(
        fname,
        dpi=500,     # resolution of the graph
        bbox_inches='tight',
        pad_inches=0.0,
        transparent=False
    )
    plt.show()


def plot_vortex_angle_field(red_positions, red_charges, xlim, ylim, density=100):
    """
    Compute and visualize the azimuthal angle field θ(x, y)
    generated by all vortices, shown in HSV colormap.
    """
    x = np.linspace(xlim[0], xlim[1], density)
    y = np.linspace(ylim[0], ylim[1], density)
    X, Y = np.meshgrid(x, y)
    U = np.zeros_like(X)
    V = np.zeros_like(Y)

    for i in range(X.shape[0]):
        for j in range(X.shape[1]):
            U[i, j], V[i, j] = vortex_field(X[i, j], Y[i, j], red_positions, red_charges)

    angle_field = np.mod(np.arctan2(V, U), np.pi)

    fig, ax = plt.subplots(figsize=(6, 6))
    im = ax.imshow(angle_field.T, extent=[xlim[0], xlim[1], ylim[0], ylim[1]],
                   origin='lower', cmap='hsv')
    plt.colorbar(im, label='azimuthal angle')
    ax.axis('off')
    plt.tight_layout()
    plt.show()
    

def plot_grid_vertices_and_vectors(grid_points, all_vertices, red_charges,
                                   Lx, Ly, 
                                   X=None, Y=None, 
                                   U=None, V=None,
                                   fname=None, stride=10):
    """
    Plot grid points, defect polygons, and optionally the vector field (U, V).

    Parameters
    ----------
    grid_points : ndarray (N, 2)
        Coordinates of grid centers.
    all_vertices : list of ndarray
        Polygon vertex coordinates for each grid cell.
    red_charges : ndarray
        Winding numbers (+/- 1/2) corresponding to defect vertices.
    Lx, Ly : float
        System size (x and y range).
    X, Y, U, V : 2D arrays, optional
        Vector field components and coordinate grids for arrow plotting.
        If provided, arrows will be overlaid.
    fname : str or None
        Output file name for saving the figure.
    stride : int
        Arrow sampling interval (default 11).
    """

    fig, ax = plt.subplots(figsize=(6, 6))
    ax.set_aspect('equal')

    # === Plot grid centers ===
    ax.plot(grid_points[:, 0], grid_points[:, 1], 'ko', markersize=5, label="grid centers")

    # === Plot polygon vertices colored by charge ===
    for verts, q in zip(all_vertices, red_charges[::sides]):
        if q < 0:
            color = 'red'    # -1/2 defects
        elif q > 0:
            color = 'blue'   # +1/2 defects
        else:
            color = 'black'
        ax.plot(verts[:, 0], verts[:, 1], 'o', c=color, markersize=5)

    # === Optionally overlay vector field ===
    if U is not None and V is not None and X is not None and Y is not None:
        # Downsample for clarity
        Xs = X[::stride, ::stride]
        Ys = Y[::stride, ::stride]
        Us = U[::stride, ::stride]
        Vs = V[::stride, ::stride]


        # Plot quiver field
        ax.quiver(
                Xs, Ys, Us, Vs,
                color='black', pivot='middle', 
                scale=80, width=0.005,
                headwidth=0, headlength=0, headaxislength=0
                )

    ax.set_xlim(0, Lx)
    ax.set_ylim(0, Ly)
    ax.axis('off')
    plt.tight_layout()

    if fname is not None:
        plt.savefig(
                    fname,
                    dpi=500,
                    bbox_inches='tight',
                    pad_inches=0.0,
                    transparent=False
                    )

    plt.show()



def select_theta_indices(theta, theta_0, delta_theta):
    """
    Select grid points where the local angle θ
    lies within ±(Δθ/2) of θ₀, considering π-periodicity.
    """
    delta = theta - theta_0
    return np.abs(delta) <= delta_theta / 2


def draw_angleplots(rgb_image, fname):
    """
    Display and save an RGB image showing the selected angle region.
    Blue = selected area; Black = background.
    """
    plt.imshow(rgb_image, origin='lower', extent=(0, np.pi, 0, np.pi))
    plt.axis('off')
    plt.savefig(
                fname,
                dpi=500,
                bbox_inches='tight',
                pad_inches=0.0,
                transparent=False
                )
    plt.show()


# ==== Main program ====

if __name__ == "__main__":
    q0 = 1            # Absolute value of the winding number at the grid point
    n = 4             # Grid resolution (n+1 points per side)
    Lx, Ly = 1.0, 1.0 # Domain size: it is just a number
    aa = Lx / n
    sides = q0 * 2    # Number of polygon edges (2 for q=1/2)
    radius = aa / 5   # Distance from center to vertex
    apert = 0        # initial azimuthal angle for each grid point
    # Generate grid centers and their winding numbers
    grid = generate_internal_grid_points(n, Lx, Ly)
    q_values = generate_winding_numbers(n, q0)
    
    
    # === create the saving folder ===
    output_dir = os.path.join(os.getcwd(), f"output_images_q={q0:d}")
    os.makedirs(output_dir, exist_ok=True)
    
    # Construct polygons and assign charges
    red_positions = []
    red_charges = []
    all_vertices = []
    for center, q in zip(grid, q_values):
        verts = generate_polygon_vertices(center, sides, radius, rotation_deg=0)
        red_positions.extend(verts)
        red_charges.extend([0.5 * q] * len(verts))
        all_vertices.append(verts)

    red_positions = np.array(red_positions)
    red_charges = np.array(red_charges)

    # Plot grid and vortex positions
    fname1 = os.path.join(output_dir, f'grid_q={q0:d}.png')
    plot_grid_and_vertices(grid, all_vertices, red_charges, Lx, Ly, fname1)

    # Compute director field
    xlim = (0, Lx)
    ylim = (0, Ly)
    density = 500 #it controls the resolution of the program. It takes a very long time if too large.
    x = np.linspace(xlim[0], xlim[1], density)
    y = np.linspace(ylim[0], ylim[1], density)
    X, Y = np.meshgrid(x, y)
    U = np.zeros_like(X)
    V = np.zeros_like(Y)

    for i in range(X.shape[0]):
        for j in range(X.shape[1]):
            U[i, j], V[i, j] = vortex_field(X[i, j], Y[i, j], red_positions, red_charges)
    
    # Plot grid and vortex positions, and vector field
    fname2 = os.path.join(output_dir, f'grid_and_vectors_q={q0:d}.png')
    plot_grid_vertices_and_vectors(
                                    grid, all_vertices, red_charges,
                                    Lx, Ly, X, Y, U, V,
                                    fname=None,
                                    stride=11
                                    )
    
    theta = np.mod(np.arctan2(V, U), np.pi)

    # Draw multiple angular isosurfaces (blue regions correspond to θ≈θ₀)
    num_angles = 10 #(number of intervals in [0, pi], because 0 and pi are the same, so it should plus 1)
    for i in range(num_angles + 1):
        theta_0 = i / num_angles * np.pi
        theta_0deg = np.rad2deg(theta_0)
        fname3 = os.path.join(output_dir, f'Isoangles_q={q0:d}_phi={theta_0deg:.3f}.png')
        delta_theta = np.pi / num_angles
        mask = select_theta_indices(theta, theta_0, delta_theta)
        rgb_image = np.zeros((density, density, 3))   # Initialize black
        rgb_image[mask] = np.array([0, 0, 1])         # Blue for selected region
        draw_angleplots(rgb_image, fname3)

    # Optionally, visualize the full vortex angle field
    # plot_vortex_angle_field(red_positions, red_charges, xlim=(0, Lx), ylim=(0, Ly), density=200)
