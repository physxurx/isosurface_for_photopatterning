#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Updated on Tue Nov 11 14:59:31 2025

@author: Rongxing Xu

add a new function that allows q0 = 1/2.
"""

"""
Created on Fri Nov  7 16:14:17 2025

Copyright © Rongxing Xu, 2025. All rights reserved.
- This program is the intellectual property of the author and may not be used,
  copied, modified, or distributed in any form without prior written permission ¥
  from the author. 
- Any use of this software is strictly subject to explicit authorization.
  Unauthorized use is strictly prohibited.

@Purpose:
    This program generates a 2D array of alternating ±1/2 vortices (defects),
    computes their orientation (director) field, and visualizes both the grid
    structure and isosurfaces of the azimuthal angle.

    It can be interpreted as a visualization of nematic liquid crystal defects
    arranged in a periodic lattice.

@author: Rongxing Xu

@email: xurongxing123@gmail.com

"""
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
from PIL import Image
# ==== Generate internal grid points ====

def generate_internal_grid_points(n, Lx, Ly):
    """
    Generate internal grid points (excluding boundaries),
    producing (n+1)^2 coordinates uniformly distributed
    within (0, Lx) x (0, Ly).
    """
    xs = np.linspace(0, Lx, n+1)  # Exclude boundary edges
    ys = np.linspace(0, Ly, n+1)
    return np.array([(x, y) for x in xs for y in ys])


def generate_winding_numbers(n, q0):
    """
    Generate alternating winding numbers q = ±q0
    on a (n+1) x (n+1) grid, using (-1)^(i+j) pattern.
    """
    return np.array([
        q0 * (-1) ** (i + j)
        for i in range(n+1)
        for j in range(n+1)
    ])


def generate_polygon_vertices(center, sides, radius, 
                              rotation_deg=0):
    """
    Generate vertices of a regular polygon.

    Parameters:
    - center: (x, y) center of the polygon
    - sides: number of edges
    - radius: distance from center to vertex
    - rotation_deg: optional rotation in degrees
    """
    if sides > 1:
        angles = np.linspace(0, 2 * np.pi, sides, endpoint=False)
        angles += np.deg2rad(rotation_deg)
        x = center[0] + radius * np.cos(angles)
        y = center[1] + radius * np.sin(angles)
    else:
        x = [center[0]]
        y = [center[1]]
    return np.stack([x, y], axis=-1)


def vortex_field(x, y, red_positions, red_charges):
    """
    Compute the director field (vx, vy) at point (x, y)
    generated by multiple vortices.

    Each vortex contributes an azimuthal rotation:
        θ += q * arctan2(dy, dx)
    where q is the winding number (±1/2).

    The resulting orientation is normalized as (cosθ, sinθ).
    """
    theta = 0
    for r0, q in zip(red_positions, red_charges):
        dx = x - r0[0]
        dy = y - r0[1]
        # theta += q * (np.arctan2(dy, dx)) + np.pi / 2
        theta += q * (np.arctan2(dy, dx))
    if n%2 == 0:
        vx = np.cos(theta + apert)
        vy = np.sin(theta + apert)
    else:
        vx = np.cos(theta + apert + np.pi/4)
        vy = np.sin(theta + apert + np.pi/4)
    return vx, vy


def plot_grid_and_vertices(grid_points, 
                           all_vertices, red_charges, 
                           Lx, Ly, fname, box =(0,0,16/25,9/25)):
    """
    Plot all grid points and their surrounding polygon vertices.
    Blue markers represent +1/2 defects,
    Red markers represent -1/2 defects.
    """
    fig, ax = plt.subplots(figsize=(16, 9))
    ax.set_aspect('equal')
    ax.plot(grid_points[:, 0], grid_points[:, 1], 'ko', markersize=10)  # Grid centers

    # Loop over polygons
    for verts, q in zip(all_vertices, red_charges[::sides]):
        if q < 0:
            color = 'red'   # -1/2 defects
        elif q > 0:
            color = 'blue'  # +1/2 defects
        ax.plot(verts[:, 0], verts[:, 1], 'o', c=color, markersize=10)

    if box is not None:
        x0, y0, w, h = box
        rect = patches.Rectangle(
            (x0*Lx, y0*Ly), w*Lx, h*Ly,
            linewidth=2, edgecolor='red', facecolor='none', linestyle='--'
        )
        ax.add_patch(rect)


    ax.set_xlim(0, Lx)
    ax.set_ylim(0, Ly)
    ax.axis('off')
    plt.tight_layout()
    plt.savefig(
        fname,
        dpi=500,     # resolution of the graph
        bbox_inches='tight',
        pad_inches=0.0,
        transparent=False
    )
    plt.show()
    

def plot_grid_vertices_and_vectors(grid_points, all_vertices, red_charges,
                                   Lx, Ly, box =(0,0,16/25,9/25),
                                   X=None, Y=None, 
                                   U=None, V=None,
                                   fname=None, stride=10):
    """
    Plot grid points, defect polygons, and optionally the vector field (U, V).

    Parameters
    ----------
    grid_points : ndarray (N, 2)
        Coordinates of grid centers.
    all_vertices : list of ndarray
        Polygon vertex coordinates for each grid cell.
    red_charges : ndarray
        Winding numbers (+/- 1/2) corresponding to defect vertices.
    Lx, Ly : float
        System size (x and y range).
    X, Y, U, V : 2D arrays, optional
        Vector field components and coordinate grids for arrow plotting.
        If provided, arrows will be overlaid.
    fname : str or None
        Output file name for saving the figure.
    stride : int
        Arrow sampling interval (default 11).
    """

    fig, ax = plt.subplots(figsize=(16, 9))
    ax.set_aspect('equal')

    # === Plot grid centers ===
    ax.plot(grid_points[:, 0], grid_points[:, 1], 'ko', markersize=10, label="grid centers")

    # === Plot polygon vertices colored by charge ===
    for verts, q in zip(all_vertices, red_charges[::sides]):
        if q < 0:
            color = 'red'    # -1/2 defects
        elif q > 0:
            color = 'blue'   # +1/2 defects
        ax.plot(verts[:, 0], verts[:, 1], 'o', c=color, markersize=10)

    # === Optionally overlay vector field ===
    if U is not None and V is not None and X is not None and Y is not None:
        # Downsample for clarity
        Xs = X[::stride, ::stride]
        Ys = Y[::stride, ::stride]
        Us = U[::stride, ::stride]
        Vs = V[::stride, ::stride]


        # Plot quiver field
        ax.quiver(
                Xs, Ys, Us, Vs,
                color='black', pivot='middle', 
                scale=80, width=0.005,
                headwidth=0, headlength=0, headaxislength=0
                )
    
    if box is not None:
        print(box)
        x0, y0, w, h = box
        rect = patches.Rectangle(
            (x0*Lx, y0*Ly), w*Lx, h*Ly,
            linewidth=2, edgecolor='red', facecolor='none', linestyle='--'
        )
        ax.add_patch(rect)
    
    
    ax.set_xlim(0, Lx)
    ax.set_ylim(0, Ly)
    ax.axis('off')
    plt.tight_layout()

    if fname is not None:
        plt.savefig(
                    fname,
                    dpi=500,
                    bbox_inches='tight',
                    pad_inches=0.0,
                    transparent=False
                    )

    plt.show()



def select_theta_indices(theta, theta_0, delta_theta):
    """
    Select grid points where the local angle θ
    lies within ±(Δθ/2) of θ₀, considering π-periodicity.
    """
    delta = theta - theta_0
    return np.abs(delta) <= delta_theta / 2


def draw_angleplots(arr, filename,
                         out_size=(1980, 1080),
                         src_box=(0,0,16/25,9/25)   # (x0, y0, w, h)
                         ):
    """
    Save a binary 2D numpy array into a fixed-size output image placing the chosen
    source crop into the destination rectangle.

    Parameters
    ----------
    arr : numpy.ndarray
        2D array of shape (H, W) with values 0 or 1 (or booleans).
    filename : str
        Path where the PNG will be saved.
    out_size : tuple
        (width_px, height_px) of the output image in pixels. Default (1980, 1080).
    src_box : None or tuple
        If None: use whole array. Otherwise (x0, y0, w, h). Coordinates can be ints
        (pixel coords in array) or floats in (0,1) interpreted as normalized fractions.
    white_value, black_value : int
        Pixel values for 1 and 0 respectively (0-255).
    """

    if arr.ndim != 2:
        raise ValueError("arr must be 2D (H, W).")
    H, W = arr.shape

    bin_arr = (arr != 0).astype(np.uint8)

    if src_box is None:
        sx0, sy0, sw, sh = 0, 0, W, H
    else:
        sx0, sy0, sw, sh = src_box
        if isinstance(sx0, float) or isinstance(sy0, float) or isinstance(sw, float) or isinstance(sh, float):
            if not (0.0 <= sx0 <= 1.0 and 0.0 <= sy0 <= 1.0 and 0.0 < sw <= 1.0 and 0.0 < sh <= 1.0):
                raise ValueError("Normalized src_box values must be in [0,1].")
            sx0 = int(round(sx0 * W))
            sy0 = int(round(sy0 * H))
            sw  = int(round(sw  * W))
            sh  = int(round(sh  * H))

    sx0 = max(0, min(sx0, W-1))
    sy0 = max(0, min(sy0, H-1))
    sw = max(1, min(sw, W - sx0))
    sh = max(1, min(sh, H - sy0))

    src_crop = bin_arr[sy0:sy0+sh, sx0:sx0+sw]
    src_crop = np.flipud(src_crop)
    
    img = Image.fromarray((src_crop * 255).astype(np.uint8), mode='L')
    img = img.resize(out_size, resample=Image.Resampling.NEAREST)

    # ---- 保存 ----
    img.save(filename, format='PNG')
    print(f"Image saved to {filename}")


# ==== Main program ====

if __name__ == "__main__":
    q0 = 1/2                            # Absolute value of the winding number at the grid point
    n = 8                               # Grid resolution (n+1 points per side)
    Lx, Ly = 1.0, 1.0                   # Domain size: it is just a number, do not change
    width_r, height_r = 16/25, 9/25     # width and height ratio for the output box, do not change
    x0, y0 = 0.5 - width_r/2, 0.5 - height_r/2                   # origin for the output box, 0 <= x0 <= Lx*(1-width_r); 0 <= y0 <= Ly*(1- height_r)
    box = (x0, y0, width_r, height_r)
    aa = Lx / n                         # lattice constant
    sides = int(q0 * 2)                 # Number of polygon edges (2 for q=1/2)
    radius = aa / 10                    # Distance from center to vertex. if q0=1/2, it can be any value that does not affect the final results
    apert = np.pi/2                     # initial azimuthal angle (rad) for each grid point
    rotation_deg = 0                    # rotation angle (degree) for each polygon at grid points
    
    # Generate grid centers and their winding numbers
    grid = generate_internal_grid_points(n, Lx, Ly)
    q_values = generate_winding_numbers(n, q0)
    
    
    # === create the saving folder ===
    output_dir = os.path.join(os.getcwd(), f"output_images_q={q0:.1f}")
    os.makedirs(output_dir, exist_ok=True)
    
    # Construct polygons and assign charges
    red_positions = []
    red_charges = []
    all_vertices = []
    for center, q in zip(grid, q_values):
        verts = generate_polygon_vertices(center, sides, radius, rotation_deg=rotation_deg) #
        red_positions.extend(verts)
        red_charges.extend([0.5 * q] * len(verts))
        all_vertices.append(verts)

    red_positions = np.array(red_positions)
    red_charges = np.array(red_charges)

    # Plot grid and vortex positions
    fname1 = os.path.join(output_dir, f'grid_q={q0:.1f}.png')
    plot_grid_and_vertices(grid, all_vertices, red_charges, Lx, Ly, fname1, box=box)

    # Compute director field
    xlim = (0, Lx)
    ylim = (0, Ly)
    density = 500 #it controls the resolution of the program. It takes a very long time if too large.
    x = np.linspace(xlim[0], xlim[1], density)
    y = np.linspace(ylim[0], ylim[1], density)
    X, Y = np.meshgrid(x, y)
    U = np.zeros_like(X)
    V = np.zeros_like(Y)

    for i in range(X.shape[0]):
        for j in range(X.shape[1]):
            U[i, j], V[i, j] = vortex_field(X[i, j], Y[i, j], red_positions, red_charges)
    
    # Plot grid and vortex positions, and vector field
    fname2 = os.path.join(output_dir, f'grid_and_vectors_q={q0:.1f}.png')
    plot_grid_vertices_and_vectors(
                                    grid, all_vertices, red_charges,
                                    Lx, Ly, box = box,
                                    X = X, Y = Y, U = U, V =V, 
                                    fname=fname2,
                                    stride=11
                                    )
    
    theta = np.mod(np.arctan2(V, U), np.pi)

    # Draw multiple angular isosurfaces (white regions correspond to θ≈θ₀)
    num_angles = 10 #(number of intervals in [0, pi], because 0 and pi are the same, so it should plus 1)
    for i in range(num_angles + 1):
        theta_0 = i / num_angles * np.pi
        theta_0deg = np.rad2deg(theta_0)
        fname3 = os.path.join(output_dir, f'Isoangles_q={q0:.1f}_phi={theta_0deg:.3f}.png')
        delta_theta = np.pi / num_angles
        mask = select_theta_indices(theta, theta_0, delta_theta)
        draw_angleplots(mask, fname3,
                                 out_size = (1920, 1080),
                                 src_box = box
                                 )

    